= slide 'Днес' do
  list:
    Регулярните изрази в бита на програмиста
    Регулярните изрази в Ruby (1.9.3)
    Как да ги ползваме в Ruby код
    Преди това, две дребни задачки, за да не ви е скучно

= slide 'Традиционната задача', 'за тези от вас, които се чувстват комфортно с РИ' do
  p Имаме следната задача:
  blockquote
    | Да се напише кратък Ruby expression, който проверява дали дадено число е просто или не,
      посредством употреба на регулярен израз. Резултатът от изпълнението му трябва да е <code>true</code>
      за прости числа и <code>false</code> за всички останали. Неща, които можете да ползвате:
    list:
      Самото число, разбира се.
      Произволни методи от класа `Regexp`
      Подходящ регулярен израз (шаблон)
      Текстовия низ `'1'`.
      `String#*`.
      Някакъв условен оператор (например `if`-`else` или `? … : …`)
      `true`, `false`, ...

= slide 'Нетрадиционната задача', 'за тези от вас, които вече ни знаят номерата' do
  p Имаме следната задача:
  blockquote
    | Да валидирате изрази от следния тип за правилно отворени/затворени скоби:
    list:
      `(car (car (car ...)))`
      Например: `(car (car (car (car list))))`
      Целта е израз, чиито резултат да може да се ползва в условен оператор (`true`/`false`-еквивалент)
      Можете да ползвате произволни методи от класа `Regexp`
      И регулярен израз, разбира се
  p.action Материалът, необходим за решаването и на двете задачи, ще го има изцяло в днешната лекция.

= slide 'Произход', 'малко обща култура' do
  list:
    На възраст над 60 години (Клини)
    Practical Extraction and Report Language
    Perl и PCRE-библиотеката (Perl-Compatible Regular Expressions)
    Почти всеки general-purpose програмен език имплементира някаква форма на РИ
    Незаменими unix-програми като `grep`, `sed`, `awk`, `vi`, `Emacs`...
    Разглеждат се дори в курса по ДМ покрай граматики и автомати

= slide 'Проблемна област', 'най-общо: работа с текстови низове' do
  list:
    Търсене на по-сложна последователност от символи в низ
    Заместване на такива последователности с нещо друго
    Изобщо, модифициране на текстови последователности (например, Markdown към HTML)
    Проверка дали даден низ отговаря на определени условия (валидация)
    Проверка дали едно число е просто или не :)

= slide 'Понятия', 'и терминология' do
  list:
    „шаблон“, още „регулярен израз“ (pattern)
    Специални символи (meta characters)
    Екраниране на специалните символи (escape-ване)
    Повторители и повторение (quantifiers and repetition)
    Класове от символи (character classes)
    Групи

= slide 'РИ в Ruby', 'синтаксис, накратко' do
  list:
    Всеки регулярен израз е обект, инстанция на класа `Regexp`
    Има литерален синтаксис за създаване на регулярни изрази: `/pattern/`
    Може да се ползва и синтаксисът с `%r`, например: `%r{/path/maching/made/easy}`
    Операциите с регулярни изрази са методи на `Regexp`, а някои са в `String`

= slide 'Regexp#match', 'ще го ползваме в примерите' do
  list:
    За да демонстрираме какво "хващат" определени шаблони, ще ползваме `Regexp#match`
    Този метод примеа аргумент текстов низ и връща `nil`, ако шаблонът не "хваща" нищо
    Връща инстанция на `MatchData`, ако шаблонът "хваща" нещо от низа
    `MatchData` в детайли — по-късно
    От тук нататък ще ползваме <em>match-ва</em> като синоним на <em>"хваща"</em> :)

= slide 'Шаблони', '(регулярни изрази, patterns и т.н.)' do
  list:
    В сърцето на всеки регулярен израз стои шаблон (pattern)
    В шаблона, всеки символ (освен някои специални) означава себе си
    Следователно, шаблонът `/dubstep/` ще отговаря на точно тази последователност от символи в низ
    Цялата магия е в специалните символи:
    `(`, `)`, `[`, `]`, `{`, `}`, `.`, `?`, `+`, `*`, `^`, `$`, `\`, ...
    Някои символи са специални само в определен контекст (например `-`)

= slide 'Най-прост пример' do
  annotate:
    /find me/.match 'Can you find me in this long sentence?'  # =>
    /find me/.match 'I am not here and you will not find ME!' # =>
  list:
    Този шаблон не съдържа специални символи
    Както виждате, по подразбиране шаблоните са чувствителни към регистъра на буквите
    Може да се промени

= slide 'Специални символи', 'meta characters' do
  list:
    `.` съвпада с един произволен символ (с изключение на символите за нов ред)
    `[` и `]` се ползват за дефиниране на класове от символи
    `*`, `?`, `+`, `{` и `}` се ползват за указване на повторения
    `^`, `$`, `\b`, `\B` и т.н. са "котви" и съответстват на определени "междусимволни дупки" :)
    `|` има смисъл на или, например:
  div.action
    annotate:
      /day|nice/.match  'A nice dance-day.'  # =>
      /da(y|n)ce/.match 'A nice dance-day.'  # =>

  p.action Внимавайте с приоритета на <code>|</code>

= slide 'Екраниране', 'на специалните символи (escape-ване)' do
  list:
    `\` пред специален символ го прави неспециален такъв (екранира го)
    За да вкарате наклонена черта, ползвате `\\` (като в обикновен низ)

= slide 'Класове от символи', '(character classes)' do
  list:
    Заградени между `[` и `]`
    Match-ват един символ от посочените вътре
    Могат да се декларират диапазони, например `[a-z]` или `[0-9A-F]`
    Ако първият символ в класа е `^`, това означава "някой символ, който не е посочен в класа"
    Можете да екранирате тире в символен клас така: `[a\-b]`
    Друг вариант е да сложите тирето в началото или в края на класа: `[-abc]` или `[abc-]` - тук то няма специален смисъл
    Има предефинирани класове от символи

= slide 'Примери с класове от символи' do
  annotate:
    /W[aeiou]rd/.match "Word" # =>
    /[0-9a-f]/.match '9f'     # =>
    /[9f]/.match     '9f'     # =>
    /[^a-z]/.match   '9f'     # =>

= slide 'Предефинирани класове от символи' do
  list:
    `\w` - символ от дума (`[a-zA-Z0-9_]`)
    `\W` - символ, който не може да участва в дума (`[^a-zA-Z0-9_]`)
    `\d` - цифра ([0-9])
    `\D` - символ, който не е цифра (`[^0-9]`)
    `\h` - шеснадесетична цифра (`[0-9a-fA-F]`)
    `\H` - символ, който не е шеснадесетична цифра (`[^0-9a-fA-F]`)
    `\s` - whitespace-символ (`/[ \t\r\n\f]/`)
    `\S` - символ, който не е whitespace (`/[^ \t\r\n\f]/`)

= slide 'POSIX-класове от символи' do
  list:
    `[[:alpha:]]` - символ от азбука
    `[[:alnum:]]` - горното или цифра
    `[[:blank:]]` - интервал или таб
    `[[:cntrl:]]` - контролен символ
    `[[:digit:]]` - цифра
    `[[:lower:]]` - малка буква
    `[[:upper:]]` - главна буква
    `[[:print:]]` - printable-символ
    `[[:punct:]]` - пунктуационен символ
    `[[:space:]]` - whitespace-символ (вкл. и нов ред)
    `[[:xdigit:]]` - шеснадеситична цифра
    И други...

= slide 'Полезни не-POSIX класове' do
  list:
    Ruby поддържа и следните не-POSIX символни класове:
    `[[:word:]]` - символ, който може да участва в дума (работи и за Unicode, за разлика от `\w`)
    `[[:ascii:]]` - ASCII-символ

= slide 'Символни свойства', 'character properties' do
  list:
    С конструкцията `\p{}` може да match-вате символи, имащи съответното свойство (подобно на POSIX)
    Например: `\p{Alnum}`, `\p{Alpha}`, `\p{Blank}`, `\p{Cntrl}`, `\p{Digit}`, `\p{Graph}`
    По този начин, например, може да проверите дали даден символ е от японската азбука катакана: `\p{Katakana}`
    Или пък да match-нете символ от азбука на кирилица: `\p{Cyrillic}`, например:

  div.action
    annotate:
      /\s\p{Cyrillic}\p{Cyrillic}\p{Cyrillic}/.match 'Ние сме на всеки километър!' # #<MatchData " сме">

= slide 'Котви' do
  list:
    Не съвпадат с реални символи, а вместо това с невидимите граници между тях
    `^` съвпада с началото на ред
    `$` съвпада с края на ред
    `\A` съвпада с началото на текстов низ
    `\z` съвпада с края на низ
    `\b` отговаря на граница на дума (когато е извън `[` и `]`; вътре означава `backspace`)
    `\B` отговаря на място, което не е граница на дума

= slide 'Примери с котви' do
  annotate:
    /real/.match "surrealist"    # =>
    /\Areal/.match "surrealist"  # =>
    /\band/.match "Demand"       # =>

    /\Band.+/.match "Supply and demand curve" # =>

= slide 'Повторители', '(quantifiers)' do
  list:
    Важат за непосредствено предхождащия ги символ/клас/група; нека го означим със `s`
    `s*` означава нула или повече повторения на `s`
    `s+` търси едно или повече повторения на `s`
    `s?` съвпада с нула или едно повторение на `s`
    `s{m,n}` означава между m и n повторения на `s`
    В последното можем да пропуснем `m` или `n`:
    `s{,n}` има смисъл на нула до `n` повторения, а `s{m,}` — поне `m` повторения

= slide 'Примери с повторители' do
  annotate:
    /e+/.match     'Keeewl'       # =>
    /[Kke]+/.match 'Keeewl'       # =>
    /\w+/.match '2038 - the year' # =>
    /".*"/.match '"Quoted text!"' # =>

    /[[:upper:]]+[[:lower:]]+l{2}o/.match 'Hello' # =>

= slide 'Алчност' do
  list:
    По подразбиране повторителите са "алчни", т.е. изяждат колкото се може повече от низа
    Това поведение може да се контролира с `?` след повторителя
    Например `.*?` прави повторението не-алчно
    Внимавайте с лакомите повторители
  div.action
    annotate:
      /<.+>/.match("<a><b>")  # =>
      /<.+?>/.match("<a><b>") # =>

= slide 'Групи', 'и прихващане' do
  p Символите <code>(</code> и <code>)</code> се използват за логическо групиране на части от шаблона с цел:
  list:
    Контролиране областта на влияние на дадена операция
    Например, следното ще match-ва низове, съдържащи думите `day` или `dance`: `/\bda(y|nce)\b/`
    Възможност за референция към „ограденото“ в скобите — в и извън шаблона
    Задаване на по-специални (и не толкова често употребявани) конструкции

= slide 'Референции към групи' do
  p Текстът, който match-ва частта на шаблона, оградена в скоби, може да се достъпва:
  list:
    В самия шаблон, с нотацията `\1` за първата група, `\2` за втората и т.н.
    Отвън, през `MatchData`-обекта
    Отвън, през специални променливи от типа на `$1`, `$2`...
    Отвън, през локални променливи, когато групите си имат име (за това след малко)

= slide 'Именовани групи' do
  list:
    Като обикновена група, само че се обръщате към тях не с цифра, а с име
    Дефинират се така: `(?&lt;name&gt;)` или така: `(?'name')`, където `name` е името на групата
    Например: `(?&lt;date&gt;\d{4}-\d{2}-\d{2})`
  div.action
    annotate:
      /(?<date>\d{4}-\d{2}-\d{2})/.match 'Today is 2011-11-08, Tuesday.' # =>

= slide 'Референции към групи', 'в рамките на шаблона' do
  list:
    `\1`, `\2` и прочее, ако групите ви не са именовани
    Ако имате повече от 9 групи, можете да ги реферирате по същия начин:
    `\11` се обръща към 11-тата група
    Ами ако искам да кажа: "текстът, отговарящ на група `\1`, последван от символа `1`"?
    Ползвате следния общ синтаксис: `\k&lt;group_identifier&gt;`, където `group_identifier` е число или име на група
    Този общ синтаксис се използва и за обръщение към текста, отговарящ на именовани групи:
    `/(?&lt;word&gt;\w+), \k&lt;word&gt;/`

= slide 'Примери за референции към групи' do
  example:
    /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/.match 'Today is 2011-11-08, Tuesday.'
    # #<MatchData "2011-11-08" year:"2011" month:"11" day:"08">

    /(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\11/.match 'Regular expressions'
    # #<MatchData "ular express" 1:"u" 2:"l" 3:"a" 4:"r" 5:" " 6:"e" 7:"x" 8:"p" 9:"r" 10:"e" 11:"s">
    /(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\k<11>1/.match 'Regular express1ions'
    # #<MatchData "ular express1" 1:"u" 2:"l" 3:"a" 4:"r" 5:" " 6:"e" 7:"x" 8:"p" 9:"r" 10:"e" 11:"s">

  list:
    Забележете, че в рамките на един шаблон <strong>не може</strong> да ползвате и двата вида рефериране към групи

= slide 'Уточнение относно референциите', 'в рамките на шаблона' do
  list:
    Обърнете внимание, че референцията е към порцията текст, match-нат от групата, а не към самата група!
    Например:
  div.action
    annotate:
      /(\w+), \1/.match 'testing, testing' # =>
      /(\w+), \1/.match 'testing, twice'   # =>

      /(?<word>\w+), \k<word>/.match 'testing, testing' # =>

= slide 'Рекурсивни групи' do
  list:
    Ако вместо порцията текст, отговаряща на дадена група, искате да преизпълните групата?
    Ползвате следния синтаксис: `\g&lt;name&gt;`, където `name` е номер или име на група в шаблона
    Това <strong>преизпълнява</strong> шаблона, не търси за вече намерения текст
    Има смисъл за да направи шаблоните ви една идея по-DRY
    Например:
  div.action
    annotate:
      /(\w+), \1/.match    'testing, twice'   # =>
      /(\w+), \g<1>/.match 'testing, twice'   # =>

= slide 'Рекурсивни групи', 'втора част' do
  list:
    С помощта на горното можете да дефинирате рекурсивни групи
    Спомняте ли си втория проблем, който поставихме в началото?
  blockquote.action
    | Да валидирате изрази от следния тип за правилно отворени/затворени скоби:
    list:
      `(car (car (car ...)))`
      Например: `(car (car (car (car list))))`
      Целта е израз, чиито резултат да може да се ползва в условен оператор (`true`/`false`-еквивалент)
      Можете да ползвате произволни методи от класа `Regexp`
      И регулярен израз, разбира се

= slide 'Примерно решение', 'с рекурсивни групи' do
  annotate:
    validator = /^(\(car \g<1>*[\w]*\))*$/

    valid   = '(car (car (car (car list))))'
    invalid = '(car (car (car list))'

    validator.match(valid) ? true : false   # =>
    validator.match(invalid) ? true : false # =>

= slide 'Look-ahead и look-behind' do
  list:
    Положителен look-ahead: `/(?=pattern)/`
    Отрицателен look-ahead: `/(?!pattern)/`
    Положителен look-behind: `/(?&lt;=pattern)/`
    Отрицателен look-behind: `/(?&gt;!pattern)/`
    Пример:
  div.action
    annotate:
      /(?<=<b>)\w+(?=<\/b>)/.match("Fortune favours the <b>bold</b>") # =>

= slide 'Работа с MatchData-обекти' do
  list:
    Това е обектът, който ви връща `Regexp#match`
    Това е обектът, стоящ зад специалната променлива `$~`
    Същият обект се крие и зад `Regexp.last_match`
    Не е `Enumerable`

= slide 'Най-полезни методи на MatchData-обектите' do
  list:
    `MatchData#[група]`, където `група` е номер или име на група, ви връща порцията текст, отговаряща на съответната група
    `MatchData#begin(група)` пък ви връща число — отместването спрямо началото на низа на порцията текст, отговаряща на съответната група
    Пример:
  div.action
    annotate:
      /(\w+)/.match('Some words')[1]              # =>
      /(\w+)/.match('Some words').begin(1)        # =>
      /(?<id>\d+)/.match('ID: 12345')[:id]        # =>
      /(?<id>\d+)/.match('ID: 12345').begin(:id)  # =>

= slide '#pre_match и #post_match методи', 'на MatchData-обектите' do
  list:
    `MatchData#pre_match` (същото като специалната променлива <code>$`</code>) — текстът преди съвпадението
    `MatchData#post_match` (същото като специалната променлива <code>$'</code>) — текстът след съвпадението
    Пример:
  div.action
    annotate:
      match = /(?<number>\d+)/.match 'ID: 12345 (new)'

      match[:number]    # =>
      match.pre_match   # =>
      match.post_match  # =>

= slide 'Специални променливи' do
  list:
    `$~`, `$'`, `$1`, `$2`, `$3` и прочее
    Не са глобални променливи, а специални (не са глобално-видими)
    Попълват се с резултата от последно изпълнения `match`
    Не само след явно извикване на `Regexp#match`

= slide 'if с регулярни изрази' do
  list:
    `=~` и `!~` — дефинирани в `Regexp` и в `String`
    Можем да правим така: `/pattern/ =~ 'Some string'`
    Както и така: `'Some string' =~ /pattern/`
    Връща `nil`, ако няма съвпадение, или число (offset), ако има такова
    След изпълнение на този оператор също имаме попълнени специални променливи
    Удобно е да се ползва в условни конструкции, например `if`

= slide 'if с регулярни изрази', 'пример' do
  annotate:
    log_entry = "[2011-07-22 15:42:12] - GET / HTTP/1.1 200 OK"

    if log_entry =~ /\bHTTP\/1.1 (\d+)/
      request_status = $1.to_i # =>
    else
      raise "Malformed log entry!"
    end

= slide 'case с регулярни изрази' do
  example:
    # html = '<h1>Header</h1>'
    html = '<img src="http://my/image.src" alt="Kartman Makes Burgers" />'

    case html
    when /(<h(\d)>)(.+)<\/h\2>/                       then {header: $3, size: $2}
    when /<a\s+href="([^"]+)">([^<]+)<\/a>/           then {url: $1, text: $2}
    when /<img\s+src="([^"]+)"\s+alt="([^"]+)"\s*\/>/ then {image: $1, alt: $2}
    else                                                   'unrecognized tag'
    end

    # {:image=>"http://my/image.src", :alt=>"Kartman Makes Burgers"}

= slide 'Методи в String', 'свързани с регулярни изрази' do
  list:
    `String#match`
    `String#=~` и `String#!=`
    `String#sub`, `String#gsub` и вариантите им с `!`
    `String#[]` и `String#slice` - в някои от вариантите си приемат регулярен израз
    `String#index` и `rindex` приемат и регулярен израз
    `String#partition` и `rpartition` и <a href="http://www.ruby-doc.org/core-1.9.3/String.html">други...</a>

= slide 'Пример със String#gsub', 'плюс групи и блок' do
  example:
    'SomeTitleCase'.gsub /(^|[[:lower:]])([[:upper:]])/ do
      [$1, $2.downcase].reject(&:empty?).join('_')
    end

    # "some_title_case"

= slide 'Unicode' do
  list:
    Регулярните изрази в Ruby 1.9 носят кодировката на сорс-кода; ако кодът е UTF-8, и те са UTF-8
    Можете да проверите кодировката на даден регулярен израз с `Regexp#encoding`
    Можете да укажете изрична кодировка посредством модификатор; например `/something/u` за `UTF-8`
    Малък пример:
  blockquote.action
    | Rubyのお父さんはまつもとゆきひろさんです。
  div.action
    annotate:
      unicode_test = 'Rubyのお父さんはまつもとゆきひろさんです。'

      /は[[:alpha:]]+さん/.match unicode_test # #<MatchData "はまつもとゆきひろさん">

= slide 'Граници на думи в Unicode-текст' do
  list:
    `\b` в Unicode-текст работи, когато границата на думата е лесно определима
    Например, това ще работи: `/\b[[:alpha:]]\b/.match 'това и онова' # #&lt;MatchData "и"&gt;`
    Горното работи, понеже думата на кирилица е оградена от интервали
    В някои езици, обаче, няма интервали (whitespace) между думите (например китайски, японски)
    Къде са границите на думите в това изречение: `Rubyのお父さんはまつもとゆきひろさんです。`?

= slide 'Граници на думи в Unicode-текст', 'пример' do
  p Например:
  div.action
    example:
      'Ruby no otousan ha Matsumoto Yukihiro san desu.'.gsub(/(\b[[:alpha:]]+\b)/) { "[#{$1}]" }
      # "[Ruby] [no] [otousan] [ha] [Matsumoto] [Yukihiro] [san] [desu]."

  p.action Но:
  div.action
    example:
      'Rubyのお父さんはまつもとゆきひろさんです。'.gsub(/(\b[[:alpha:]]+\b)/) { "[#{$1}]" }
      # "[Rubyのお父さんはまつもとゆきひろさんです]。"

= slide 'Флагове на шаблоните' do
  list:
    Можете да управлявате някои аспекти от поведението на шаблона посредством флагове
    Указват се след края на шаблона, например: `/pattern/flags`
    `i` прави търсенето на съвпадение нечувствително към регистъра на буквите
    `u` кара шаблона да носи задължителна кодировка `UTF-8`
    `m` превръща шаблона в multiline-такъв (в този режим, например, `.` ще съвпада и с нов ред)
    Има и други, които не се ползват толкова често

= slide 'Решение на проблема, поставен днес', 'проверка за просто число с РИ' do
  list:
    Идеи, предложения?
    `'1' * числото =~ /някакъв регулярен израз/ ? false : true`
    `'1' * 13 =~ /^1?$|^(11+?)\1+$/ ? false : true`
    Много полезно знание :) Въпроси по израза?
    Регулярният израз тук може да се ползва 1:1 в Python за същата цел

= slide 'Документация' do
  list:
    `Regexp`: <a href="http://www.ruby-doc.org/core-1.9.3/Regexp.html">http://www.ruby-doc.org/core-1.9.3/Regexp.html</a>
    `MatchData`: <a href="http://www.ruby-doc.org/core-1.9.3/MatchData.html">http://www.ruby-doc.org/core-1.9.3/MatchData.html</a>
    През `ri`, например: `ri Regexp#=~`
    Мейл до Стефан със subject: `RE: <моят въпрос>`, той ще го Google-не вместо вас и ще ви върне отговор в body-то на email-а
