= slide 'Днес' do
  list:
    Регулярните изрази в бита на програмиста
    Регулярните изрази в Ruby (1.9.3)
    Как да ги ползваме в Ruby код
    Преди това, две дребни задачки, за да не ви е скучно

= slide 'Традиционната задача', 'за тези от вас, които се чувстват комфортно с РИ' do
  p Имаме следната задача:
  blockquote
    | Да се напише кратък Ruby expression, който проверява дали дадено число е просто или не,
      посредством употреба на регулярен израз. Резултатът от изпълнението му трябва да е <code>true</code>
      за прости числа и <code>false</code> за всички останали. Неща, които можете да ползвате:
    list:
      Самото число, разбира се.
      Произволни методи от класа `Regexp`
      Подходящ регулярен израз (шаблон)
      Текстовия низ `'1'`.
      `String#*`.
      Някакъв условен оператор (например `if`-`else` или `? … : …`)
      `true`, `false`, ...

= slide 'Нетрадиционната задача', 'за тези от вас, които вече ни знаят номерата' do
  p Имаме следната задача:
  blockquote
    | Да валидирате изрази от следния тип за правилно отворени/затворени скоби:
    list:
      `(car (car (car ...)))`
      Например: `(car (car (car (car list))))`
      Целта е израз, чиито резултат да може да се ползва в условен оператор (`true`/`false`-еквивалент)
      Можете да ползвате произволни методи от класа `Regexp`
      И регулярен израз, разбира се
  p.action Материалът, необходим за решаването и на двете задачи, ще го има изцяло в днешната лекция.

= slide 'Произход', 'малко обща култура' do
  list:
    На възраст над 60 години (Клини)
    Practical Extraction and Report Language
    Perl и PCRE-библиотеката (Perl-Compatible Regular Expressions)
    Почти всеки general-purpose програмен език имплементира някаква форма на РИ
    Незаменими unix-програми като `grep`, `sed`, `awk`, `vi`, `Emacs`...
    Разглеждат се дори в курса по ДМ покрай граматики и автомати

= slide 'Проблемна област', 'най-общо: работа с текстови низове' do
  list:
    Търсене на по-сложна последователност от символи в низ
    Заместване на такива последователности с нещо друго
    Изобщо, модифициране на текстови последователности (например, Markdown към HTML)
    Проверка дали даден низ отговаря на определени условия (валидация)
    Проверка дали едно число е просто или не :)

= slide 'Понятия', 'и терминология' do
  list:
    „шаблон“, още „регулярен израз“ (pattern)
    Специални символи (meta characters)
    Екраниране на специалните символи (escape-ване)
    Повторители и повторение (quantifiers and repetition)
    Класове от символи (character classes)
    Групи

= slide 'РИ в Ruby', 'синтаксис, накратко' do
  list:
    Всеки регулярен израз е обект, инстанция на класа `Regexp`
    Има литерален синтаксис за създаване на регулярни изрази: `/pattern/`
    Може да се ползва и синтаксисът с `%r`, например: `%r{/path/maching/made/easy}`
    Операциите с регулярни изрази са методи на `Regexp`, а някои са в `String`

= slide 'Regexp#match', 'ще го ползваме в примерите' do
  list:
    За да демонстрираме какво "хващат" определени шаблони, ще ползваме `Regexp#match`
    Този метод примеа аргумент текстов низ и връща `nil`, ако шаблонът не "хваща" нищо
    Връща инстанция на `MatchData`, ако шаблонът "хваща" нещо от низа
    `MatchData` в детайли — по-късно
    От тук нататък ще ползваме <em>match-ва</em> като синоним на <em>"хваща"</em> :)

= slide 'Шаблони', '(регулярни изрази, patterns и т.н.)' do
  list:
    В сърцето на всеки регулярен израз стои шаблон (pattern)
    В шаблона, всеки символ (освен някои специални) означава себе си
    Следователно, шаблонът `/dubstep/` ще отговаря на точно тази последователност от символи в низ
    Цялата магия е в специалните символи:
    `(`, `)`, `[`, `]`, `{`, `}`, `.`, `?`, `+`, `*`, `^`, `$`, `\`, ...
    Някои символи са специални само в определен контекст (например `-`)

= slide 'Най-прост пример' do
  annotate:
    /find me/.match 'Can you find me in this long sentence?'  # =>
    /find me/.match 'I am not here and you will not find ME!' # =>
  list:
    Този шаблон не съдържа специални символи
    Както виждате, по подразбиране шаблоните са чувствителни към регистъра на буквите
    Може да се промени

= slide 'Специални символи', 'meta characters' do
  list:
    `.` съвпада с един произволен символ (с изключение на символите за нов ред)
    `[` и `]` се ползват за дефиниране на класове от символи
    `*`, `?`, `+`, `{` и `}` се ползват за указване на повторения
    `^`, `$`, `\b`, `\B` и т.н. са "котви" и съответстват на определени "междусимволни дупки" :)
    `|` има смисъл на или, например:
  div.action
    annotate:
      /day|nice/.match  'A nice dance-day.'  # =>
      /da(y|n)ce/.match 'A nice dance-day.'  # =>

  p.action Внимавайте с приоритета на <code>|</code>

= slide 'Екраниране', 'на специалните символи (escape-ване)' do
  list:
    `\` пред специален символ го прави неспециален такъв (екранира го)
    За да вкарате наклонена черта, ползвате `\\` (като в обикновен низ)

= slide 'Класове от символи', '(character classes)' do
  list:
    Заградени между `[` и `]`
    Match-ват един символ от посочените вътре
    Могат да се декларират диапазони, например `[a-z]` или `[0-9A-F]`
    Ако първият символ в класа е `^`, това означава "някой символ, който не е посочен в класа"
    Можете да екранирате тире в символен клас така: `[a\-b]`
    Друг вариант е да сложите тирето в началото или в края на класа: `[-abc]` или `[abc-]` - тук то няма специален смисъл
    Има предефинирани класове от символи

= slide 'Примери с класове от символи' do
  annotate:
    /W[aeiou]rd/.match "Word" # =>
    /[0-9a-f]/.match '9f'     # =>
    /[9f]/.match     '9f'     # =>
    /[^a-z]/.match   '9f'     # =>

= slide 'Предефинирани класове от символи' do
  list:
    `\w` - символ от дума (`[a-zA-Z0-9_]`)
    `\W` - символ, който не може да участва в дума (`[^a-zA-Z0-9_]`)
    `\d` - цифра ([0-9])
    `\D` - символ, който не е цифра (`[^0-9]`)
    `\h` - шеснадесетична цифра (`[0-9a-fA-F]`)
    `\H` - символ, който не е шеснадесетична цифра (`[^0-9a-fA-F]`)
    `\s` - whitespace-символ (`/[ \t\r\n\f]/`)
    `\S` - символ, който не е whitespace (`/[^ \t\r\n\f]/`)

= slide 'POSIX-класове от символи' do
  list:
    `[[:alpha:]]` - символ от азбука
    `[[:alnum:]]` - горното или цифра
    `[[:blank:]]` - интервал или таб
    `[[:cntrl:]]` - контролен символ
    `[[:digit:]]` - цифра
    `[[:lower:]]` - малка буква
    `[[:upper:]]` - главна буква
    `[[:print:]]` - printable-символ
    `[[:punct:]]` - пунктуационен символ
    `[[:space:]]` - whitespace-символ (вкл. и нов ред)
    `[[:xdigit:]]` - шеснадеситична цифра
    И други...

= slide 'Полезни не-POSIX класове' do
  list:
    Ruby поддържа и следните не-POSIX символни класове:
    `[[:word:]]` - символ, който може да участва в дума (работи и за Unicode, за разлика от `\w`)
    `[[:ascii:]]` - ASCII-символ

= slide 'Символни свойства', 'character properties' do
  list:
    С конструкцията `\p{}` може да match-вате символи, имащи съответното свойство (подобно на POSIX)
    Например: `\p{Alnum}`, `\p{Alpha}`, `\p{Blank}`, `\p{Cntrl}`, `\p{Digit}`, `\p{Graph}`
    По този начин, например, може да проверите дали даден символ е от японската азбука катакана: `\p{Katakana}`
    Или пък да match-нете символ от азбука на кирилица: `\p{Cyrillic}`, например:

  div.action
    annotate:
      /\s\p{Cyrillic}\p{Cyrillic}\p{Cyrillic}/.match 'Ние сме на всеки километър!' # #<MatchData " сме">

= slide 'Котви' do
  list:
    Не съвпадат с реални символи, а вместо това с невидимите граници между тях
    `^` съвпада с началото на ред
    `$` съвпада с края на ред
    `\A` съвпада с началото на текстов низ
    `\z` съвпада с края на низ
    `\b` отговаря на граница на дума (когато е извън `[` и `]`; вътре означава `backspace`)
    `\B` отговаря на място, което не е граница на дума

= slide 'Примери с котви' do
  annotate:
    /real/.match "surrealist"    # =>
    /\Areal/.match "surrealist"  # =>
    /\band/.match "Demand"       # =>

    /\Band.+/.match "Supply and demand curve" # =>

= slide 'Повторители', '(quantifiers)' do
  list:
    Важат за непосредствено предхождащия ги символ/клас/група; нека го означим със `s`
    `s*` означава нула или повече повторения на `s`
    `s+` търси едно или повече повторения на `s`
    `s?` съвпада с нула или едно повторение на `s`
    `s{m,n}` означава между m и n повторения на `s`
    В последното можем да пропуснем `m` или `n`:
    `s{,n}` има смисъл на нула до `n` повторения, а `s{m,}` — поне `m` повторения

= slide 'Примери с повторители' do
  annotate:
    /e+/.match     'Keeewl'       # =>
    /[Kke]+/.match 'Keeewl'       # =>
    /\w+/.match '2038 - the year' # =>
    /".*"/.match '"Quoted text!"' # =>

    /[[:upper:]]+[[:lower:]]+l{2}o/.match 'Hello' # =>

= slide 'Алчност' do
  list:
    По подразбиране повторителите са "алчни", т.е. изяждат колкото се може повече от низа
    Това поведение може да се контролира с `?` след повторителя
    Например `.*?` прави повторението не-алчно
    Внимавайте с лакомите повторители
  div.action
    annotate:
      /<.+>/.match("<a><b>")  # =>
      /<.+?>/.match("<a><b>") # =>

= slide 'Групи', 'и прихващане' do
  p Символите <code>(</code> и <code>)</code> се използват за логическо групиране на части от шаблона с цел:
  list:
    Контролиране областта на влияние на дадена операция
    Възможност за референция към „ограденото“ в скобите
    Задаване на по-специални (и не толкова често употребявани) конструкции
    Повече за групите — след малко

= slide 'Референции към групи' do
  p Текстът, който match-ва частта на шаблона, оградена в скоби, може да се достъпва:
  list:
    Отвън, през `MatchData`-обекта
    Отвън, през специални променливи от типа на `$1`, `$2`...
    Отвън, през локални променливи, когато групите си имат име
    В самия шаблон, с нотацията `\1` за първата група, `\2` за втората и т.н.
    ТОДО: Референция към 11-та група

= slide 'Именовани групи' do
  list:
    TODO

= slide 'Рекурсивни групи' do
  list:
    TODO

= slide 'Look-ahead' do
  list:
    TODO

= slide 'Look-behind' do
  list:
    TODO

= slide 'Работа с MatchData-обекти' do
  list:
    TODO

= slide 'В Ruby-код', 'регулярните изрази са навсякъде' do
  list:
    `Regexp#match` и `MatchData`-класът
    `=~` и `!~`
    Регулярни изрази в `if` и `case` — live demo :)

= slide 'Методи в String', 'свързани с регулярни изрази' do
  list:
    `String#match`
    `String#=~` и `String#!=`
    `String#sub`, `String#gsub` и вариантите им с `!`
    `String#[]` и `String#slice` - в някои от вариантите си приемат регулярен израз
    `String#index` и `rindex` приемат и регулярен израз
    `String#partition` и `rpartition` и <a href="http://www.ruby-doc.org/core-1.9.3/String.html">други...</a>

= slide 'Пример със String#gsub', 'плюс групи и блок' do
  example:
    'SomeTitleCase'.gsub /(^|[[:lower:]])([[:upper:]])/ do
      [$1, $2.downcase].reject(&:empty?).join('_')
    end

    # "some_title_case"

= slide 'Unicode' do
  list:
    Регулярните изрази в Ruby 1.9 носят кодировката на сорс-кода; ако кодът е UTF-8, и те са UTF-8
    Можете да проверите кодировката на даден регулярен израз с `Regexp#encoding`
    Можете да укажете изрична кодировка посредством модификатор; например `/something/u` за `UTF-8`
    Малък пример:
  blockquote.action
    | Rubyのお父さんはまつもとゆきひろさんです。
  div.action
    annotate:
      unicode_test = 'Rubyのお父さんはまつもとゆきひろさんです。'

      /は[[:alpha:]]+さん/.match unicode_test # #<MatchData "はまつもとゆきひろさん">

= slide 'Граници на думи в Unicode-текст' do
  list:
    `\b` в Unicode-текст работи, когато границата на думата е лесно определима
    Например, това ще работи: `/\b[[:alpha:]]\b/.match 'това и онова' # #&lt;MatchData "и"&gt;`
    Горното работи, понеже думата на кирилица е оградена от интервали
    В някои езици, обаче, няма интервали (whitespace) между думите (например китайски, японски)
    Къде са границите на думите в това изречение: `Rubyのお父さんはまつもとゆきひろさんです。`?

= slide 'Граници на думи в Unicode-текст', 'пример' do
  p Например:
  div.action
    example:
      'Ruby no otousan ha Matsumoto Yukihiro san desu.'.gsub(/(\b[[:alpha:]]+\b)/) { "[#{$1}]" }
      # "[Ruby] [no] [otousan] [ha] [Matsumoto] [Yukihiro] [san] [desu]."

  p.action Но:
  div.action
    example:
      'Rubyのお父さんはまつもとゆきひろさんです。'.gsub(/(\b[[:alpha:]]+\b)/) { "[#{$1}]" }
      # "[Rubyのお父さんはまつもとゆきひろさんです]。"

= slide 'Решение на проблема, поставен днес', 'проверка за просто число с РИ' do
  list:
    Идеи, предложения?
    `'1' * числото =~ /някакъв регулярен израз/ ? false : true`
    `'1' * 13 =~ /^1?$|^(11+?)\1+$/ ? false : true`
    Много полезно знание :) Въпроси по израза?
    Регулярният израз тук може да се ползва 1:1 в Python за същата цел

= slide 'Документация' do
  list:
    Официална: <a href="http://www.ruby-doc.org/core-1.9.3/Regexp.html">http://www.ruby-doc.org/core-1.9.3/Regexp.html</a>
    През `ri`, например: `ri Regexp#=~`
    Мейл до Стефан със subject: `RE: <моят въпрос>`, той ще го Google-не вместо вас и ще ви върне отговор в body-то на email-а
